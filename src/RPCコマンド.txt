Canarium RPC URIクエリ

最大74バイトのパケットデータをBase64urlでエンコードした文字列(最大100文字)をGETリクエストで送信する。
処理中または他のクライアントが使用中の場合にGETリクエストを行うと、他の処理が終わるまで待たされる。

パケットデータフォーマット
+0  2  ID値
+2  1  ペイロード長(nを示す)
+3  1  チェック値(ペイロードデータの各バイトをチェック演算した値)
+4  n  ペイロードデータ(FlashAir W4.00.01では最大70バイト)
:
+73

・チェック値計算
for(x=0,i=0 ; i<n ; i++) x = byte[i] ^ ((x<<1)|((x & 0x80)? 1:0));
if ((x ^ check) & 0xff) printf("NG");


返値は下記のJSON-RPC形式で返される。

・HTTPレスポンスヘッダ
HTTP/1.1 200 OK
Connection: close
Content-Type: application/json; charset=utf-8
Content-Length: <jsonのバイト数>

・正常レスポンス
{
  "jsonrpc": "2.0",
  "result": <boolean> or <number> or <base64url string>,
  "id": <number>
}

・エラーレスポンス
{
  "jsonrpc": "2.0",
  "error": {
    "code": <integer>,
    "message": <string>
  },
  "id": <number>
}

"jsonrpc": "2.0"の固定値が入る
"id": パケットに設定されたID値が入る
"result": 正常終了の場合に結果が入る。boolean、32bit整数値、Base64urlでエンコードされたバイナリ列のどれか
"error": エラーの場合、このオブジェクトが返る
"code": エラーコードが数値で入る。値はJSON-RPCに準拠
"message": エラーメッセージがある場合はこのキーに入る

・エラーコード
{"code":-32700, "message":"Parse error"}
パースエラー。URIクエリをデコードできなかった、または不正なパケット形式を検出した場合。

{"code":-32601, "message":"Method not found"}
コマンド（メソッド）が存在しない場合。

{"code":-32000, "message":<エラーメッセージ>}
コマンドの実行が失敗した場合。messageキーには内部で返されるメッセージが入る。


・URIクエリなしにGETリクエストをした場合ライブラリのバージョンを返す。

・FPGAコンフィグレーションコマンド

CONFコマンド

ペイロードデータ：0x80 <RBFファイル名>

指定のRBFファイルでFPGAをコンフィグレーションする
ただし、キャッシュファイルが存在すればそれを使用する

コマンド完了でresult=trueを返す。
実行完了またはエラー発生までレスポンスが返らないため、動作ステータスは共有メモリにアクセスして確認しなければならない。


FCONFコマンド

ペイロードデータ：0x81 <RBFファイル名>

指定RBFファイルでFPGAをコンフィグレーションする
キャッシュファイルを新しく作成し直す

レスポンスは0x80コマンドと同様


CHECKコマンド

ペイロードデータ：0x8f

FPGAのコンフィグレーションの有無を調べる
コンフィグレーションされていれば1、されていなければ0をresultで返す。


・AvalonMMアクセスコマンド

IOWRコマンド

ペイロードデータ：0x10 0x55 <アドレス> <書き込みデータ>

指定のアドレスにデータを書き込む。
アドレスデータは4バイトでネットワークバイトオーダーで指定する。
書き込みデータは4バイトでネットワークバイトオーダーで指定する。
このコマンドはAvalonMMのメモリバス上で32bit単位のアトミックなアクセスを行う。
アドレスは32bit境界に整列していなければならない。

コマンド完了でresult=trueを返す。


IORDコマンド

ペイロードデータ：0x11 0x55 <アドレス>

指定のアドレスからデータを読み出す。
アドレスデータは4バイトで、ネットワークバイトオーダーで指定する。
このコマンドはAvalonMMのメモリバス上で32bit単位のアトミックなアクセスを行う。
アドレスは32bit境界に整列していなければならない。

読み出し値はresultキーに符号無し32bitの値で返される。


MEMWRコマンド

ペイロードデータ：0x18 0x55 <アドレス> <書き込みデータ>

指定のアドレスにデータを書き込む。
アドレスデータは4バイトでネットワークバイトオーダーで指定する。
書き込みデータはバイトアドレス順で格納する。
W4.00.01では書き込みデータの最大長は64バイト。

コマンド完了でresult=trueを返す。


MEMRDコマンド

ペイロードデータ：0x19 0x55 <アドレス> <読み出しバイト数>

指定のアドレスからデータを読み出す。
アドレスデータは4バイトでネットワークバイトオーダーで指定する。
読み出しバイト数は2バイトでネットワークバイトオーダーで指定する。
W4.00.01では読み出しデータの最大長は256バイト。

読み出し値はresultキーにBase64urlエンコードされた文字列で返される。


・ファイルイメージコマンド

BLOADコマンド

ペイロードデータ：0x20 0x55 <アドレス> <ファイル名>

指定のアドレスに指定されたファイル名の内容を書き込む。
アドレスデータは4バイトでネットワークバイトオーダーで指定する。

コマンド完了でresult=trueを返す。
実行完了またはエラー発生までレスポンスが返らないため、動作ステータスは共有メモリにアクセスして確認しなければならない。


BSAVEコマンド

ペイロードデータ：0x21 0x55 <アドレス> <データサイズ> <ファイル名>

指定のアドレスからデータサイズのバイトをファイルに書き出す。
アドレスデータは4バイトでネットワークバイトオーダーで指定する。
データサイズは4バイトでネットワークバイトオーダーで指定する。
既存ファイルが存在した場合は上書きされる。

レスポンスは0x20コマンドと同様


HEXLOADコマンド

ペイロードデータ：0x22 0x55 <オフセットアドレス> <ファイル名>

ファイル名で指定されたIntelHEX(.hex)またはSフォーマット(.s)ファイルをオフセットアドレスを先頭アドレスとしてロードする。
オフセットアドレスは4バイトでネットワークバイトオーダーで指定する。

レスポンスは0x20コマンドと同様


・実行中ステータス
コマンド実行中は共有メモリに最長100バイトのjson形式のステータスを格納する。
クライアントからはcommand.cgi?op=130&ADDR=512&LEN=100を使って取得する

JSONデータは下記のフォーマットで格納される
'{"key":%5d,"id":%5d,"command":%3d,"progress":[%3d,%3d, ...]}\0'

key     : プロセス番号(Lua実行時に設定する1～65535の整数値)
id      : ID値(パケットデータのID値が入る0~65535の整数値)
command : 実行中のコマンド番号
progress: コマンドの進捗度が各ステージ分の配列として入る

